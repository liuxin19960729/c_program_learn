# 前置处理器
```c
##:连接符号

宏
__POSIX_SOURCE:
// 选用不同的furture
// gcc 对每个特性有不同的实现方法 
#define  __POSIX_SOURCE 200809L 

// 编译时根据不同的x类型选择对应的数据类型的函数
#define mar_ff(x) \
    _Generic((x),double:ffd,int:ffi,default:ffd)(x)


gnu 扩展
__typeof__(a)  a的类型

#define DOUBLE(x) ({ \
    __typeof__(x) _d_x=(x);\
   _d_x+_d_x; \
})
int z(){
    return 2000;
}
#include<stdio.h>
int main(int argc, char const *argv[])
{
    int a=100;
    printf("%d\n",DOUBLE(z()));    
    return 0;
}

会被编译成
int main(int argc, char const *argv[])
{
    int a=100;
    printf("%d\n",({ __typeof__(z()) _d_x=(z()); _d_x+_d_x; }));
    return 0;
}


clang c++ 支持 Block
// -fblocks
#define DOUBLE_BLOCK(x) \
    (^(__typeof__(x) __a_in__double_block)  \
    { return __a_in__double_block+__a_in__double_block; }(x))
```
## 利用 前置编译初始化 list
```c
c99
compound literal

struct llist
{
    int val;
    struct llist *next;
};

#define llist_concat(val, next) \
    (struct llist[]) { val, next }

int main(int argc, char const *argv[])
{
    struct llist *list = llist_concat(1, llist_concat(2, llist_concat(3, NULL)));
    while (!!list)
    {
        printf("%d\n", list->val);
        list = list->next;
    }

    return 0;
}
```